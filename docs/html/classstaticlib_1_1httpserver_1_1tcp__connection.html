<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>staticlib_httpserver: staticlib::httpserver::tcp_connection Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">staticlib_httpserver
   &#160;<span id="projectnumber">5.0.7.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacestaticlib.html">staticlib</a></li><li class="navelem"><a class="el" href="namespacestaticlib_1_1httpserver.html">httpserver</a></li><li class="navelem"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html">tcp_connection</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classstaticlib_1_1httpserver_1_1tcp__connection-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">staticlib::httpserver::tcp_connection Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a single tcp connection.  
 <a href="classstaticlib_1_1httpserver_1_1tcp__connection.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tcp__connection_8hpp_source.html">staticlib/httpserver/tcp_connection.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for staticlib::httpserver::tcp_connection:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classstaticlib_1_1httpserver_1_1tcp__connection.png" usemap="#staticlib::httpserver::tcp_connection_map" alt=""/>
  <map id="staticlib::httpserver::tcp_connection_map" name="staticlib::httpserver::tcp_connection_map">
<area href="classstaticlib_1_1httpserver_1_1noncopyable___1_1noncopyable.html" alt="staticlib::httpserver::noncopyable_::noncopyable" shape="rect" coords="0,0,282,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection_1_1ssl__socket__type.html">ssl_socket_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy data type for an SSL-like socket connection in non-SSL environment.  <a href="classstaticlib_1_1httpserver_1_1tcp__connection_1_1ssl__socket__type.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a34f52d3bb70c101adbb91cbfba883f62"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a34f52d3bb70c101adbb91cbfba883f62">lifecycle_type</a> { <a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a34f52d3bb70c101adbb91cbfba883f62a0be9978ba39523e021ded48d16114e24">LIFECYCLE_CLOSE</a>, 
<a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a34f52d3bb70c101adbb91cbfba883f62a9a0388819ba6809ea038b4528469332d">LIFECYCLE_KEEPALIVE</a>, 
<a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a34f52d3bb70c101adbb91cbfba883f62ac96f71c277087acbfaa13bc1496ed583">LIFECYCLE_PIPELINED</a>
 }</td></tr>
<tr class="memdesc:a34f52d3bb70c101adbb91cbfba883f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for the connection's lifecycle state.  <a href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a34f52d3bb70c101adbb91cbfba883f62">More...</a><br/></td></tr>
<tr class="memitem:a722627d7e3647e68b3b5bac0f0cfe961"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a722627d7e3647e68b3b5bac0f0cfe961ae0c6e7819e6d85898e5ae5217ff432b4">READ_BUFFER_SIZE</a> =  8192
 }</td></tr>
<tr class="memdesc:a722627d7e3647e68b3b5bac0f0cfe961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the read buffer.  <a href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a722627d7e3647e68b3b5bac0f0cfe961">More...</a><br/></td></tr>
<tr class="memitem:af9b7d0561f8cfeb0ea6a34faf07bcba0"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; void(std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html">tcp_connection</a> &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#af9b7d0561f8cfeb0ea6a34faf07bcba0">connection_handler</a></td></tr>
<tr class="memdesc:af9b7d0561f8cfeb0ea6a34faf07bcba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for a function that handles TCP connection objects.  <a href="#af9b7d0561f8cfeb0ea6a34faf07bcba0"></a><br/></td></tr>
<tr class="memitem:a2e2fdb71f5f75ec449402d8658228bb5"><td class="memItemLeft" align="right" valign="top">typedef std::array&lt; char, <br class="typebreak"/>
<a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a722627d7e3647e68b3b5bac0f0cfe961ae0c6e7819e6d85898e5ae5217ff432b4">READ_BUFFER_SIZE</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a2e2fdb71f5f75ec449402d8658228bb5">read_buffer_type</a></td></tr>
<tr class="memdesc:a2e2fdb71f5f75ec449402d8658228bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for an I/O read buffer.  <a href="#a2e2fdb71f5f75ec449402d8658228bb5"></a><br/></td></tr>
<tr class="memitem:a2e232af3c3d216bb3d3fadc1428a175f"><td class="memItemLeft" align="right" valign="top">typedef asio::ip::tcp::socket&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a2e232af3c3d216bb3d3fadc1428a175f">socket_type</a></td></tr>
<tr class="memdesc:a2e232af3c3d216bb3d3fadc1428a175f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for a socket connection.  <a href="#a2e232af3c3d216bb3d3fadc1428a175f"></a><br/></td></tr>
<tr class="memitem:ae0445cb223ff80d9afb7b08375460574"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#ae0445cb223ff80d9afb7b08375460574">ssl_context_type</a></td></tr>
<tr class="memdesc:ae0445cb223ff80d9afb7b08375460574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy data type for SSL configuration context in non-SSL environment.  <a href="#ae0445cb223ff80d9afb7b08375460574"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af0ad076f187f841d7573b7fd23c0cb94"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#af0ad076f187f841d7573b7fd23c0cb94">~tcp_connection</a> ()</td></tr>
<tr class="memdesc:af0ad076f187f841d7573b7fd23c0cb94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <a href="#af0ad076f187f841d7573b7fd23c0cb94"></a><br/></td></tr>
<tr class="memitem:accda76ac25f7b894a825c20228290a7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#accda76ac25f7b894a825c20228290a7f">is_open</a> () const </td></tr>
<tr class="memdesc:accda76ac25f7b894a825c20228290a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the connection is currently open.  <a href="#accda76ac25f7b894a825c20228290a7f"></a><br/></td></tr>
<tr class="memitem:a43eb63a009b0d84b53103892d8d543d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a43eb63a009b0d84b53103892d8d543d0">close</a> ()</td></tr>
<tr class="memdesc:a43eb63a009b0d84b53103892d8d543d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the tcp socket and cancels any pending asynchronous operations.  <a href="#a43eb63a009b0d84b53103892d8d543d0"></a><br/></td></tr>
<tr class="memitem:a9dc545b39de89b81c035109f4ead5e5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a9dc545b39de89b81c035109f4ead5e5b">cancel</a> ()</td></tr>
<tr class="memdesc:a9dc545b39de89b81c035109f4ead5e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels any asynchronous operations pending on the socket.  <a href="#a9dc545b39de89b81c035109f4ead5e5b"></a><br/></td></tr>
<tr class="memitem:a7579dce3251f06d6042d2a188eedb15f"><td class="memTemplParams" colspan="2">template&lt;typename AcceptHandler &gt; </td></tr>
<tr class="memitem:a7579dce3251f06d6042d2a188eedb15f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a7579dce3251f06d6042d2a188eedb15f">async_accept</a> (asio::ip::tcp::acceptor &amp;tcp_acceptor, AcceptHandler handler)</td></tr>
<tr class="memdesc:a7579dce3251f06d6042d2a188eedb15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously accepts a new tcp connection.  <a href="#a7579dce3251f06d6042d2a188eedb15f"></a><br/></td></tr>
<tr class="memitem:a6191945f610b207179bf15a6634f18bd"><td class="memTemplParams" colspan="2">template&lt;typename SSLHandshakeHandler &gt; </td></tr>
<tr class="memitem:a6191945f610b207179bf15a6634f18bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a6191945f610b207179bf15a6634f18bd">async_handshake_server</a> (SSLHandshakeHandler handler)</td></tr>
<tr class="memdesc:a6191945f610b207179bf15a6634f18bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously performs server-side SSL handshake for a new connection.  <a href="#a6191945f610b207179bf15a6634f18bd"></a><br/></td></tr>
<tr class="memitem:add4b08c7622b59615c08562b54d5eb64"><td class="memTemplParams" colspan="2">template&lt;typename ReadHandler &gt; </td></tr>
<tr class="memitem:add4b08c7622b59615c08562b54d5eb64"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#add4b08c7622b59615c08562b54d5eb64">async_read_some</a> (ReadHandler handler)</td></tr>
<tr class="memdesc:add4b08c7622b59615c08562b54d5eb64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously reads some data into the connection's read buffer.  <a href="#add4b08c7622b59615c08562b54d5eb64"></a><br/></td></tr>
<tr class="memitem:adb1d01b1fd272d368266a3d41b0173ac"><td class="memTemplParams" colspan="2">template&lt;typename ReadBufferType , typename ReadHandler &gt; </td></tr>
<tr class="memitem:adb1d01b1fd272d368266a3d41b0173ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#adb1d01b1fd272d368266a3d41b0173ac">async_read_some</a> (ReadBufferType read_buffer, ReadHandler handler)</td></tr>
<tr class="memdesc:adb1d01b1fd272d368266a3d41b0173ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously reads some data into the connection's read buffer.  <a href="#adb1d01b1fd272d368266a3d41b0173ac"></a><br/></td></tr>
<tr class="memitem:ae9e48eb113906533af42b4a1758eff3e"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#ae9e48eb113906533af42b4a1758eff3e">read_some</a> (asio::error_code &amp;ec)</td></tr>
<tr class="memdesc:ae9e48eb113906533af42b4a1758eff3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads some data into the connection's read buffer (blocks until finished)  <a href="#ae9e48eb113906533af42b4a1758eff3e"></a><br/></td></tr>
<tr class="memitem:a43ca6051803213431949f9664b8cc733"><td class="memTemplParams" colspan="2">template&lt;typename ReadBufferType &gt; </td></tr>
<tr class="memitem:a43ca6051803213431949f9664b8cc733"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a43ca6051803213431949f9664b8cc733">read_some</a> (ReadBufferType read_buffer, asio::error_code &amp;ec)</td></tr>
<tr class="memdesc:a43ca6051803213431949f9664b8cc733"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads some data into the connection's read buffer (blocks until finished)  <a href="#a43ca6051803213431949f9664b8cc733"></a><br/></td></tr>
<tr class="memitem:a4ee54b2875f72cdec23a779665e442b7"><td class="memTemplParams" colspan="2">template&lt;typename CompletionCondition , typename ReadHandler &gt; </td></tr>
<tr class="memitem:a4ee54b2875f72cdec23a779665e442b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a4ee54b2875f72cdec23a779665e442b7">async_read</a> (CompletionCondition completion_condition, ReadHandler handler)</td></tr>
<tr class="memdesc:a4ee54b2875f72cdec23a779665e442b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously reads data into the connection's read buffer until completion_condition is met.  <a href="#a4ee54b2875f72cdec23a779665e442b7"></a><br/></td></tr>
<tr class="memitem:a87d534a85b354fffa51f745d1c167aee"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence , typename CompletionCondition , typename ReadHandler &gt; </td></tr>
<tr class="memitem:a87d534a85b354fffa51f745d1c167aee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a87d534a85b354fffa51f745d1c167aee">async_read</a> (const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, ReadHandler handler)</td></tr>
<tr class="memdesc:a87d534a85b354fffa51f745d1c167aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously reads data from the connection until completion_condition is met.  <a href="#a87d534a85b354fffa51f745d1c167aee"></a><br/></td></tr>
<tr class="memitem:a1e9932a3ac932662d79026c3114f2d85"><td class="memTemplParams" colspan="2">template&lt;typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a1e9932a3ac932662d79026c3114f2d85"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a1e9932a3ac932662d79026c3114f2d85">read</a> (CompletionCondition completion_condition, asio::error_code &amp;ec)</td></tr>
<tr class="memdesc:a1e9932a3ac932662d79026c3114f2d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data into the connection's read buffer until completion_condition is met (blocks until finished)  <a href="#a1e9932a3ac932662d79026c3114f2d85"></a><br/></td></tr>
<tr class="memitem:ad6221f3ed1b32deba92ac7e2a8145c7c"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ad6221f3ed1b32deba92ac7e2a8145c7c"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#ad6221f3ed1b32deba92ac7e2a8145c7c">read</a> (const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, asio::error_code &amp;ec)</td></tr>
<tr class="memdesc:ad6221f3ed1b32deba92ac7e2a8145c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from the connection until completion_condition is met (blocks until finished)  <a href="#ad6221f3ed1b32deba92ac7e2a8145c7c"></a><br/></td></tr>
<tr class="memitem:af83abd12a576fe917155711a03d8b952"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence , typename write_handler_t &gt; </td></tr>
<tr class="memitem:af83abd12a576fe917155711a03d8b952"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#af83abd12a576fe917155711a03d8b952">async_write</a> (const ConstBufferSequence &amp;buffers, write_handler_t handler)</td></tr>
<tr class="memdesc:af83abd12a576fe917155711a03d8b952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously writes data to the connection.  <a href="#af83abd12a576fe917155711a03d8b952"></a><br/></td></tr>
<tr class="memitem:a2d73f4fe9380103fef493a1103a2d0f3"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a2d73f4fe9380103fef493a1103a2d0f3"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a2d73f4fe9380103fef493a1103a2d0f3">write</a> (const ConstBufferSequence &amp;buffers, asio::error_code &amp;ec)</td></tr>
<tr class="memdesc:a2d73f4fe9380103fef493a1103a2d0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to the connection (blocks until finished)  <a href="#a2d73f4fe9380103fef493a1103a2d0f3"></a><br/></td></tr>
<tr class="memitem:a606ca1f3f0d792b9749ed9c88a1ef78b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a606ca1f3f0d792b9749ed9c88a1ef78b">finish</a> ()</td></tr>
<tr class="memdesc:a606ca1f3f0d792b9749ed9c88a1ef78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function should be called when a server has finished handling the connection.  <a href="#a606ca1f3f0d792b9749ed9c88a1ef78b"></a><br/></td></tr>
<tr class="memitem:a0932425d8805e38ea805cef3f9ddddf5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a0932425d8805e38ea805cef3f9ddddf5">get_ssl_flag</a> () const </td></tr>
<tr class="memdesc:a0932425d8805e38ea805cef3f9ddddf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the connection is encrypted using SSL.  <a href="#a0932425d8805e38ea805cef3f9ddddf5"></a><br/></td></tr>
<tr class="memitem:a93dd322461d6eb0090537cb0ef27b105"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a93dd322461d6eb0090537cb0ef27b105">set_lifecycle</a> (<a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a34f52d3bb70c101adbb91cbfba883f62">lifecycle_type</a> t)</td></tr>
<tr class="memdesc:a93dd322461d6eb0090537cb0ef27b105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the lifecycle type for the connection.  <a href="#a93dd322461d6eb0090537cb0ef27b105"></a><br/></td></tr>
<tr class="memitem:a06c187eefcd8c8c275c7e375a3d2dcf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a34f52d3bb70c101adbb91cbfba883f62">lifecycle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a06c187eefcd8c8c275c7e375a3d2dcf6">get_lifecycle</a> () const </td></tr>
<tr class="memdesc:a06c187eefcd8c8c275c7e375a3d2dcf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lifecycle type for the connection.  <a href="#a06c187eefcd8c8c275c7e375a3d2dcf6"></a><br/></td></tr>
<tr class="memitem:ab09505f344ebb68239415a48208a5cff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#ab09505f344ebb68239415a48208a5cff">get_keep_alive</a> () const </td></tr>
<tr class="memdesc:ab09505f344ebb68239415a48208a5cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the connection should be kept alive.  <a href="#ab09505f344ebb68239415a48208a5cff"></a><br/></td></tr>
<tr class="memitem:acbd451cbed3234db2df283d26c694481"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#acbd451cbed3234db2df283d26c694481">get_pipelined</a> () const </td></tr>
<tr class="memdesc:acbd451cbed3234db2df283d26c694481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the HTTP requests are pipelined.  <a href="#acbd451cbed3234db2df283d26c694481"></a><br/></td></tr>
<tr class="memitem:aca991a2ad9d130d5e7b30b17a031545d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a2e2fdb71f5f75ec449402d8658228bb5">read_buffer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#aca991a2ad9d130d5e7b30b17a031545d">get_read_buffer</a> ()</td></tr>
<tr class="memdesc:aca991a2ad9d130d5e7b30b17a031545d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the buffer used for reading data from the TCP connection.  <a href="#aca991a2ad9d130d5e7b30b17a031545d"></a><br/></td></tr>
<tr class="memitem:a14e9524689a99523eb5f0137269f38a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a14e9524689a99523eb5f0137269f38a5">save_read_pos</a> (const char *read_ptr, const char *read_end_ptr)</td></tr>
<tr class="memdesc:a14e9524689a99523eb5f0137269f38a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a read position bookmark.  <a href="#a14e9524689a99523eb5f0137269f38a5"></a><br/></td></tr>
<tr class="memitem:ab7abcc9deae3b698a08ff08f2f55987d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#ab7abcc9deae3b698a08ff08f2f55987d">load_read_pos</a> (const char *&amp;read_ptr, const char *&amp;read_end_ptr) const </td></tr>
<tr class="memdesc:ab7abcc9deae3b698a08ff08f2f55987d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a read position bookmark.  <a href="#ab7abcc9deae3b698a08ff08f2f55987d"></a><br/></td></tr>
<tr class="memitem:a7ab88b18c47bf7b9d8eb99619173d91d"><td class="memItemLeft" align="right" valign="top">asio::ip::tcp::endpoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a7ab88b18c47bf7b9d8eb99619173d91d">get_remote_endpoint</a> () const </td></tr>
<tr class="memdesc:a7ab88b18c47bf7b9d8eb99619173d91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an ASIO endpoint for the client connection.  <a href="#a7ab88b18c47bf7b9d8eb99619173d91d"></a><br/></td></tr>
<tr class="memitem:a2c8f19fcc1f6f59376569ed6c8e55f4b"><td class="memItemLeft" align="right" valign="top">asio::ip::address&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a2c8f19fcc1f6f59376569ed6c8e55f4b">get_remote_ip</a> () const </td></tr>
<tr class="memdesc:a2c8f19fcc1f6f59376569ed6c8e55f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the client's IP address.  <a href="#a2c8f19fcc1f6f59376569ed6c8e55f4b"></a><br/></td></tr>
<tr class="memitem:ab515494500c0408a3df8a9117ddf6f11"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#ab515494500c0408a3df8a9117ddf6f11">get_remote_port</a> () const </td></tr>
<tr class="memdesc:ab515494500c0408a3df8a9117ddf6f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the client's port number.  <a href="#ab515494500c0408a3df8a9117ddf6f11"></a><br/></td></tr>
<tr class="memitem:a5206d1971512d0cdf69fb07ba38da765"><td class="memItemLeft" align="right" valign="top">asio::io_service &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a5206d1971512d0cdf69fb07ba38da765">get_io_service</a> ()</td></tr>
<tr class="memdesc:a5206d1971512d0cdf69fb07ba38da765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the io_service used for async operations.  <a href="#a5206d1971512d0cdf69fb07ba38da765"></a><br/></td></tr>
<tr class="memitem:aa6357225a5fb30c0e0695669b48647be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a2e232af3c3d216bb3d3fadc1428a175f">socket_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#aa6357225a5fb30c0e0695669b48647be">get_socket</a> ()</td></tr>
<tr class="memdesc:aa6357225a5fb30c0e0695669b48647be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-const reference to underlying TCP socket object.  <a href="#aa6357225a5fb30c0e0695669b48647be"></a><br/></td></tr>
<tr class="memitem:a5ef54fe05277a6067c972a1712c0a906"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection_1_1ssl__socket__type.html">ssl_socket_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a5ef54fe05277a6067c972a1712c0a906">get_ssl_socket</a> ()</td></tr>
<tr class="memdesc:a5ef54fe05277a6067c972a1712c0a906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-const reference to underlying SSL socket object.  <a href="#a5ef54fe05277a6067c972a1712c0a906"></a><br/></td></tr>
<tr class="memitem:a07f85d2ed4c8eeba7c14f6de4246df70"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a2e232af3c3d216bb3d3fadc1428a175f">socket_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a07f85d2ed4c8eeba7c14f6de4246df70">get_socket</a> () const </td></tr>
<tr class="memdesc:a07f85d2ed4c8eeba7c14f6de4246df70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to underlying TCP socket object.  <a href="#a07f85d2ed4c8eeba7c14f6de4246df70"></a><br/></td></tr>
<tr class="memitem:a4cd7d24513441763e4b4a78c92c83064"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection_1_1ssl__socket__type.html">ssl_socket_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a4cd7d24513441763e4b4a78c92c83064">get_ssl_socket</a> () const </td></tr>
<tr class="memdesc:a4cd7d24513441763e4b4a78c92c83064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to underlying SSL socket object.  <a href="#a4cd7d24513441763e4b4a78c92c83064"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a40f79f0b2edeea34e2837f72b7886d85"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html">tcp_connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a40f79f0b2edeea34e2837f72b7886d85">create</a> (asio::io_service &amp;io_service, <a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#ae0445cb223ff80d9afb7b08375460574">ssl_context_type</a> &amp;ssl_context, const bool ssl_flag, <a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#af9b7d0561f8cfeb0ea6a34faf07bcba0">connection_handler</a> finished_handler)</td></tr>
<tr class="memdesc:a40f79f0b2edeea34e2837f72b7886d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates new shared connection objects  <a href="#a40f79f0b2edeea34e2837f72b7886d85"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a27bc7685abc92ffbbceb33a2cbdf21f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a27bc7685abc92ffbbceb33a2cbdf21f7">tcp_connection</a> (asio::io_service &amp;io_service, <a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#ae0445cb223ff80d9afb7b08375460574">ssl_context_type</a> &amp;ssl_context, const bool ssl_flag, <a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#af9b7d0561f8cfeb0ea6a34faf07bcba0">connection_handler</a> finished_handler)</td></tr>
<tr class="memdesc:a27bc7685abc92ffbbceb33a2cbdf21f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">protected constructor restricts creation of objects (use <a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a40f79f0b2edeea34e2837f72b7886d85" title="creates new shared connection objects">create()</a>)  <a href="#a27bc7685abc92ffbbceb33a2cbdf21f7"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Represents a single tcp connection. </p>
</div><h2>Member Typedef Documentation</h2>
<a class="anchor" id="af9b7d0561f8cfeb0ea6a34faf07bcba0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;void(std::shared_ptr&lt;<a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html">tcp_connection</a>&gt;&amp;)&gt; <a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#af9b7d0561f8cfeb0ea6a34faf07bcba0">staticlib::httpserver::tcp_connection::connection_handler</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data type for a function that handles TCP connection objects. </p>

</div>
</div>
<a class="anchor" id="a2e2fdb71f5f75ec449402d8658228bb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::array&lt;char, <a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a722627d7e3647e68b3b5bac0f0cfe961ae0c6e7819e6d85898e5ae5217ff432b4">READ_BUFFER_SIZE</a>&gt; <a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a2e2fdb71f5f75ec449402d8658228bb5">staticlib::httpserver::tcp_connection::read_buffer_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data type for an I/O read buffer. </p>

</div>
</div>
<a class="anchor" id="a2e232af3c3d216bb3d3fadc1428a175f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef asio::ip::tcp::socket <a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a2e232af3c3d216bb3d3fadc1428a175f">staticlib::httpserver::tcp_connection::socket_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data type for a socket connection. </p>

</div>
</div>
<a class="anchor" id="ae0445cb223ff80d9afb7b08375460574"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#ae0445cb223ff80d9afb7b08375460574">staticlib::httpserver::tcp_connection::ssl_context_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dummy data type for SSL configuration context in non-SSL environment. </p>

</div>
</div>
<h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a722627d7e3647e68b3b5bac0f0cfe961"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the read buffer. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a722627d7e3647e68b3b5bac0f0cfe961ae0c6e7819e6d85898e5ae5217ff432b4"></a>READ_BUFFER_SIZE</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a34f52d3bb70c101adbb91cbfba883f62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a34f52d3bb70c101adbb91cbfba883f62">staticlib::httpserver::tcp_connection::lifecycle_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data type for the connection's lifecycle state. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a34f52d3bb70c101adbb91cbfba883f62a0be9978ba39523e021ded48d16114e24"></a>LIFECYCLE_CLOSE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a34f52d3bb70c101adbb91cbfba883f62a9a0388819ba6809ea038b4528469332d"></a>LIFECYCLE_KEEPALIVE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a34f52d3bb70c101adbb91cbfba883f62ac96f71c277087acbfaa13bc1496ed583"></a>LIFECYCLE_PIPELINED</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af0ad076f187f841d7573b7fd23c0cb94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual staticlib::httpserver::tcp_connection::~tcp_connection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual destructor. </p>

</div>
</div>
<a class="anchor" id="a27bc7685abc92ffbbceb33a2cbdf21f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">staticlib::httpserver::tcp_connection::tcp_connection </td>
          <td>(</td>
          <td class="paramtype">asio::io_service &amp;&#160;</td>
          <td class="paramname"><em>io_service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#ae0445cb223ff80d9afb7b08375460574">ssl_context_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ssl_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ssl_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#af9b7d0561f8cfeb0ea6a34faf07bcba0">connection_handler</a>&#160;</td>
          <td class="paramname"><em>finished_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>protected constructor restricts creation of objects (use <a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a40f79f0b2edeea34e2837f72b7886d85" title="creates new shared connection objects">create()</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_service</td><td>asio service associated with the connection </td></tr>
    <tr><td class="paramname">ssl_context</td><td>asio ssl context associated with the connection </td></tr>
    <tr><td class="paramname">ssl_flag</td><td>if true then the connection will be encrypted using SSL </td></tr>
    <tr><td class="paramname">finished_handler</td><td>function called when a server has finished handling the connection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a7579dce3251f06d6042d2a188eedb15f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AcceptHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::httpserver::tcp_connection::async_accept </td>
          <td>(</td>
          <td class="paramtype">asio::ip::tcp::acceptor &amp;&#160;</td>
          <td class="paramname"><em>tcp_acceptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AcceptHandler&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously accepts a new tcp connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tcp_acceptor</td><td>object used to accept new connections </td></tr>
    <tr><td class="paramname">handler</td><td>called after a new connection has been accepted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>asio::basic_socket_acceptor::async_accept() </dd></dl>

</div>
</div>
<a class="anchor" id="a6191945f610b207179bf15a6634f18bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SSLHandshakeHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::httpserver::tcp_connection::async_handshake_server </td>
          <td>(</td>
          <td class="paramtype">SSLHandshakeHandler&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously performs server-side SSL handshake for a new connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>called after the ssl handshake has completed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>asio::ssl::stream::async_handshake() </dd></dl>

</div>
</div>
<a class="anchor" id="a4ee54b2875f72cdec23a779665e442b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionCondition , typename ReadHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::httpserver::tcp_connection::async_read </td>
          <td>(</td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously reads data into the connection's read buffer until completion_condition is met. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">completion_condition</td><td>determines if the read operation is complete </td></tr>
    <tr><td class="paramname">handler</td><td>called after the read operation has completed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>asio::async_read() </dd></dl>

</div>
</div>
<a class="anchor" id="a87d534a85b354fffa51f745d1c167aee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBufferSequence , typename CompletionCondition , typename ReadHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::httpserver::tcp_connection::async_read </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously reads data from the connection until completion_condition is met. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>one or more buffers into which the data will be read </td></tr>
    <tr><td class="paramname">completion_condition</td><td>determines if the read operation is complete </td></tr>
    <tr><td class="paramname">handler</td><td>called after the read operation has completed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>asio::async_read() </dd></dl>

</div>
</div>
<a class="anchor" id="add4b08c7622b59615c08562b54d5eb64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReadHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::httpserver::tcp_connection::async_read_some </td>
          <td>(</td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously reads some data into the connection's read buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>called after the read operation has completed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>asio::basic_stream_socket::async_read_some() </dd></dl>

</div>
</div>
<a class="anchor" id="adb1d01b1fd272d368266a3d41b0173ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReadBufferType , typename ReadHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::httpserver::tcp_connection::async_read_some </td>
          <td>(</td>
          <td class="paramtype">ReadBufferType&#160;</td>
          <td class="paramname"><em>read_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously reads some data into the connection's read buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_buffer</td><td>the buffer to read data into </td></tr>
    <tr><td class="paramname">handler</td><td>called after the read operation has completed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>asio::basic_stream_socket::async_read_some() </dd></dl>

</div>
</div>
<a class="anchor" id="af83abd12a576fe917155711a03d8b952"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConstBufferSequence , typename write_handler_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::httpserver::tcp_connection::async_write </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">write_handler_t&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously writes data to the connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>one or more buffers containing the data to be written </td></tr>
    <tr><td class="paramname">handler</td><td>called after the data has been written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>asio::async_write() </dd></dl>

</div>
</div>
<a class="anchor" id="a9dc545b39de89b81c035109f4ead5e5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::httpserver::tcp_connection::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancels any asynchronous operations pending on the socket. </p>

</div>
</div>
<a class="anchor" id="a43eb63a009b0d84b53103892d8d543d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::httpserver::tcp_connection::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the tcp socket and cancels any pending asynchronous operations. </p>

</div>
</div>
<a class="anchor" id="a40f79f0b2edeea34e2837f72b7886d85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html">tcp_connection</a>&gt; staticlib::httpserver::tcp_connection::create </td>
          <td>(</td>
          <td class="paramtype">asio::io_service &amp;&#160;</td>
          <td class="paramname"><em>io_service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#ae0445cb223ff80d9afb7b08375460574">ssl_context_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ssl_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ssl_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#af9b7d0561f8cfeb0ea6a34faf07bcba0">connection_handler</a>&#160;</td>
          <td class="paramname"><em>finished_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates new shared connection objects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_service</td><td>asio service associated with the connection </td></tr>
    <tr><td class="paramname">ssl_context</td><td>asio ssl context associated with the connection </td></tr>
    <tr><td class="paramname">ssl_flag</td><td>if true then the connection will be encrypted using SSL </td></tr>
    <tr><td class="paramname">finished_handler</td><td>function called when a server has finished handling the connection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a606ca1f3f0d792b9749ed9c88a1ef78b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::httpserver::tcp_connection::finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function should be called when a server has finished handling the connection. </p>

</div>
</div>
<a class="anchor" id="a5206d1971512d0cdf69fb07ba38da765"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asio::io_service&amp; staticlib::httpserver::tcp_connection::get_io_service </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to the io_service used for async operations. </p>
<dl class="section return"><dt>Returns</dt><dd>io_service used for async operations </dd></dl>

</div>
</div>
<a class="anchor" id="ab09505f344ebb68239415a48208a5cff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool staticlib::httpserver::tcp_connection::get_keep_alive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the connection should be kept alive. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a06c187eefcd8c8c275c7e375a3d2dcf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a34f52d3bb70c101adbb91cbfba883f62">lifecycle_type</a> staticlib::httpserver::tcp_connection::get_lifecycle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the lifecycle type for the connection. </p>
<dl class="section return"><dt>Returns</dt><dd>lifecycle type name </dd></dl>

</div>
</div>
<a class="anchor" id="acbd451cbed3234db2df283d26c694481"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool staticlib::httpserver::tcp_connection::get_pipelined </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the HTTP requests are pipelined. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the HTTP requests are pipelined </dd></dl>

</div>
</div>
<a class="anchor" id="aca991a2ad9d130d5e7b30b17a031545d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a2e2fdb71f5f75ec449402d8658228bb5">read_buffer_type</a>&amp; staticlib::httpserver::tcp_connection::get_read_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the buffer used for reading data from the TCP connection. </p>
<dl class="section return"><dt>Returns</dt><dd>buffer used for reading data from the TCP connection </dd></dl>

</div>
</div>
<a class="anchor" id="a7ab88b18c47bf7b9d8eb99619173d91d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asio::ip::tcp::endpoint staticlib::httpserver::tcp_connection::get_remote_endpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an ASIO endpoint for the client connection. </p>
<dl class="section return"><dt>Returns</dt><dd>endpoint </dd></dl>

</div>
</div>
<a class="anchor" id="a2c8f19fcc1f6f59376569ed6c8e55f4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asio::ip::address staticlib::httpserver::tcp_connection::get_remote_ip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the client's IP address. </p>
<dl class="section return"><dt>Returns</dt><dd>client's IP address </dd></dl>

</div>
</div>
<a class="anchor" id="ab515494500c0408a3df8a9117ddf6f11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short staticlib::httpserver::tcp_connection::get_remote_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the client's port number. </p>
<dl class="section return"><dt>Returns</dt><dd>client's port number </dd></dl>

</div>
</div>
<a class="anchor" id="aa6357225a5fb30c0e0695669b48647be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a2e232af3c3d216bb3d3fadc1428a175f">socket_type</a>&amp; staticlib::httpserver::tcp_connection::get_socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns non-const reference to underlying TCP socket object. </p>
<dl class="section return"><dt>Returns</dt><dd>underlying TCP socket object </dd></dl>

</div>
</div>
<a class="anchor" id="a07f85d2ed4c8eeba7c14f6de4246df70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a2e232af3c3d216bb3d3fadc1428a175f">socket_type</a>&amp; staticlib::httpserver::tcp_connection::get_socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns const reference to underlying TCP socket object. </p>
<dl class="section return"><dt>Returns</dt><dd>underlying TCP socket object </dd></dl>

</div>
</div>
<a class="anchor" id="a0932425d8805e38ea805cef3f9ddddf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool staticlib::httpserver::tcp_connection::get_ssl_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the connection is encrypted using SSL. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the connection is encrypted using SSL </dd></dl>

</div>
</div>
<a class="anchor" id="a5ef54fe05277a6067c972a1712c0a906"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection_1_1ssl__socket__type.html">ssl_socket_type</a>&amp; staticlib::httpserver::tcp_connection::get_ssl_socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns non-const reference to underlying SSL socket object. </p>
<dl class="section return"><dt>Returns</dt><dd>underlying SSL socket object </dd></dl>

</div>
</div>
<a class="anchor" id="a4cd7d24513441763e4b4a78c92c83064"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection_1_1ssl__socket__type.html">ssl_socket_type</a>&amp; staticlib::httpserver::tcp_connection::get_ssl_socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns const reference to underlying SSL socket object. </p>
<dl class="section return"><dt>Returns</dt><dd>underlying SSL socket object </dd></dl>

</div>
</div>
<a class="anchor" id="accda76ac25f7b894a825c20228290a7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool staticlib::httpserver::tcp_connection::is_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the connection is currently open. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the connection is currently open </dd></dl>

</div>
</div>
<a class="anchor" id="ab7abcc9deae3b698a08ff08f2f55987d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::httpserver::tcp_connection::load_read_pos </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>read_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>read_end_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a read position bookmark. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_ptr</td><td>points to the next character to be consumed in the read_buffer </td></tr>
    <tr><td class="paramname">read_end_ptr</td><td>points to the end of the read_buffer (last byte + 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e9932a3ac932662d79026c3114f2d85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t staticlib::httpserver::tcp_connection::read </td>
          <td>(</td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asio::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data into the connection's read buffer until completion_condition is met (blocks until finished) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">completion_condition</td><td>determines if the read operation is complete </td></tr>
    <tr><td class="paramname">ec</td><td>contains error code if the read fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::size_t number of bytes read</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>asio::read() </dd></dl>

</div>
</div>
<a class="anchor" id="ad6221f3ed1b32deba92ac7e2a8145c7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBufferSequence , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t staticlib::httpserver::tcp_connection::read </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asio::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data from the connection until completion_condition is met (blocks until finished) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>one or more buffers into which the data will be read </td></tr>
    <tr><td class="paramname">completion_condition</td><td>determines if the read operation is complete </td></tr>
    <tr><td class="paramname">ec</td><td>contains error code if the read fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::size_t number of bytes read</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>asio::read() </dd></dl>

</div>
</div>
<a class="anchor" id="ae9e48eb113906533af42b4a1758eff3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t staticlib::httpserver::tcp_connection::read_some </td>
          <td>(</td>
          <td class="paramtype">asio::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads some data into the connection's read buffer (blocks until finished) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>contains error code if the read fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::size_t number of bytes read</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>asio::basic_stream_socket::read_some() </dd></dl>

</div>
</div>
<a class="anchor" id="a43ca6051803213431949f9664b8cc733"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReadBufferType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t staticlib::httpserver::tcp_connection::read_some </td>
          <td>(</td>
          <td class="paramtype">ReadBufferType&#160;</td>
          <td class="paramname"><em>read_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asio::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reads some data into the connection's read buffer (blocks until finished) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_buffer</td><td>the buffer to read data into </td></tr>
    <tr><td class="paramname">ec</td><td>contains error code if the read fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::size_t number of bytes read</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>asio::basic_stream_socket::read_some() </dd></dl>

</div>
</div>
<a class="anchor" id="a14e9524689a99523eb5f0137269f38a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::httpserver::tcp_connection::save_read_pos </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>read_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>read_end_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a read position bookmark. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_ptr</td><td>points to the next character to be consumed in the read_buffer </td></tr>
    <tr><td class="paramname">read_end_ptr</td><td>points to the end of the read_buffer (last byte + 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a93dd322461d6eb0090537cb0ef27b105"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::httpserver::tcp_connection::set_lifecycle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstaticlib_1_1httpserver_1_1tcp__connection.html#a34f52d3bb70c101adbb91cbfba883f62">lifecycle_type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the lifecycle type for the connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>lifecycle type name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d73f4fe9380103fef493a1103a2d0f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t staticlib::httpserver::tcp_connection::write </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asio::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data to the connection (blocks until finished) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>one or more buffers containing the data to be written </td></tr>
    <tr><td class="paramname">ec</td><td>contains error code if the write fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::size_t number of bytes written</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>asio::write() </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>staticlib/httpserver/<a class="el" href="tcp__connection_8hpp_source.html">tcp_connection.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 16 2016 09:35:46 for staticlib_httpserver by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
