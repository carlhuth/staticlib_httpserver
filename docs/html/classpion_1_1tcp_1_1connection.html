<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>staticlib_httpserver: pion::tcp::connection Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">staticlib_httpserver
   &#160;<span id="projectnumber">5.0.7.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepion.html">pion</a></li><li class="navelem"><a class="el" href="namespacepion_1_1tcp.html">tcp</a></li><li class="navelem"><a class="el" href="classpion_1_1tcp_1_1connection.html">connection</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classpion_1_1tcp_1_1connection-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pion::tcp::connection Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a single tcp connection.  
 <a href="classpion_1_1tcp_1_1connection.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="connection_8hpp_source.html">pion/tcp/connection.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pion::tcp::connection:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpion_1_1tcp_1_1connection.png" usemap="#pion::tcp::connection_map" alt=""/>
  <map id="pion::tcp::connection_map" name="pion::tcp::connection_map">
<area href="classpion_1_1noncopyable___1_1noncopyable.html" alt="pion::noncopyable_::noncopyable" shape="rect" coords="0,0,201,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection_1_1ssl__socket__type.html">ssl_socket_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy data type for an SSL-like socket connection in non-SSL environment.  <a href="classpion_1_1tcp_1_1connection_1_1ssl__socket__type.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1888aaf31f431a3f00c70c2568f4cb25"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a1888aaf31f431a3f00c70c2568f4cb25">lifecycle_type</a> { <a class="el" href="classpion_1_1tcp_1_1connection.html#a1888aaf31f431a3f00c70c2568f4cb25a1eee3589ec1f6b59a13bc36fd5f48e63">LIFECYCLE_CLOSE</a>, 
<a class="el" href="classpion_1_1tcp_1_1connection.html#a1888aaf31f431a3f00c70c2568f4cb25ab3bb67380ff48e263e16b55ff786e96f">LIFECYCLE_KEEPALIVE</a>, 
<a class="el" href="classpion_1_1tcp_1_1connection.html#a1888aaf31f431a3f00c70c2568f4cb25ac3e9ae9a9b7a71232679416d57b7d95f">LIFECYCLE_PIPELINED</a>
 }</td></tr>
<tr class="memdesc:a1888aaf31f431a3f00c70c2568f4cb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for the connection's lifecycle state.  <a href="classpion_1_1tcp_1_1connection.html#a1888aaf31f431a3f00c70c2568f4cb25">More...</a><br/></td></tr>
<tr class="memitem:ad123ec22701e50c2c39d4a6cdbea3e92"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classpion_1_1tcp_1_1connection.html#ad123ec22701e50c2c39d4a6cdbea3e92aac7c4dbea8f7fc8b471d7fcabf619221">READ_BUFFER_SIZE</a> =  8192
 }</td></tr>
<tr class="memdesc:ad123ec22701e50c2c39d4a6cdbea3e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the read buffer.  <a href="classpion_1_1tcp_1_1connection.html#ad123ec22701e50c2c39d4a6cdbea3e92">More...</a><br/></td></tr>
<tr class="memitem:afc2e9e9be4eb1d914504aa4d741c9d6c"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; void(std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classpion_1_1tcp_1_1connection.html">connection</a> &gt;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#afc2e9e9be4eb1d914504aa4d741c9d6c">connection_handler</a></td></tr>
<tr class="memdesc:afc2e9e9be4eb1d914504aa4d741c9d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for a function that handles TCP connection objects.  <a href="#afc2e9e9be4eb1d914504aa4d741c9d6c"></a><br/></td></tr>
<tr class="memitem:a099608c1f163f46624069e01a3c1284a"><td class="memItemLeft" align="right" valign="top">typedef std::array&lt; char, <br class="typebreak"/>
<a class="el" href="classpion_1_1tcp_1_1connection.html#ad123ec22701e50c2c39d4a6cdbea3e92aac7c4dbea8f7fc8b471d7fcabf619221">READ_BUFFER_SIZE</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a099608c1f163f46624069e01a3c1284a">read_buffer_type</a></td></tr>
<tr class="memdesc:a099608c1f163f46624069e01a3c1284a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for an I/O read buffer.  <a href="#a099608c1f163f46624069e01a3c1284a"></a><br/></td></tr>
<tr class="memitem:a5ca4d0a8aab48603b5d7670960693861"><td class="memItemLeft" align="right" valign="top">typedef asio::ip::tcp::socket&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a5ca4d0a8aab48603b5d7670960693861">socket_type</a></td></tr>
<tr class="memdesc:a5ca4d0a8aab48603b5d7670960693861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for a socket connection.  <a href="#a5ca4d0a8aab48603b5d7670960693861"></a><br/></td></tr>
<tr class="memitem:a8587c35bbf48a119aa82f228e779a30e"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a8587c35bbf48a119aa82f228e779a30e">ssl_context_type</a></td></tr>
<tr class="memdesc:a8587c35bbf48a119aa82f228e779a30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy data type for SSL configuration context in non-SSL environment.  <a href="#a8587c35bbf48a119aa82f228e779a30e"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acfec04a4c239aabdfd7842471101e325"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#acfec04a4c239aabdfd7842471101e325">connection</a> (asio::io_service &amp;io_service, <a class="el" href="classpion_1_1tcp_1_1connection.html#a8587c35bbf48a119aa82f228e779a30e">ssl_context_type</a> &amp;ssl_context)</td></tr>
<tr class="memdesc:acfec04a4c239aabdfd7842471101e325"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a new connection object for SSL  <a href="#acfec04a4c239aabdfd7842471101e325"></a><br/></td></tr>
<tr class="memitem:a4fbf93efbbb9f67dbe882c33ce3964da"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a4fbf93efbbb9f67dbe882c33ce3964da">~connection</a> ()</td></tr>
<tr class="memdesc:a4fbf93efbbb9f67dbe882c33ce3964da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <a href="#a4fbf93efbbb9f67dbe882c33ce3964da"></a><br/></td></tr>
<tr class="memitem:a8fe2d278e93663648d844004a4b8ddc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a8fe2d278e93663648d844004a4b8ddc6">is_open</a> () const </td></tr>
<tr class="memdesc:a8fe2d278e93663648d844004a4b8ddc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the connection is currently open.  <a href="#a8fe2d278e93663648d844004a4b8ddc6"></a><br/></td></tr>
<tr class="memitem:ac544e2fda25b3fb88407edb471a2f869"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#ac544e2fda25b3fb88407edb471a2f869">close</a> ()</td></tr>
<tr class="memdesc:ac544e2fda25b3fb88407edb471a2f869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the tcp socket and cancels any pending asynchronous operations.  <a href="#ac544e2fda25b3fb88407edb471a2f869"></a><br/></td></tr>
<tr class="memitem:a40e5a1fb2afd5c9d2696f15e4090bbe5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a40e5a1fb2afd5c9d2696f15e4090bbe5">cancel</a> ()</td></tr>
<tr class="memdesc:a40e5a1fb2afd5c9d2696f15e4090bbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels any asynchronous operations pending on the socket.  <a href="#a40e5a1fb2afd5c9d2696f15e4090bbe5"></a><br/></td></tr>
<tr class="memitem:a11085b098393116dfd32f893fc8ea95d"><td class="memTemplParams" colspan="2">template&lt;typename AcceptHandler &gt; </td></tr>
<tr class="memitem:a11085b098393116dfd32f893fc8ea95d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a11085b098393116dfd32f893fc8ea95d">async_accept</a> (asio::ip::tcp::acceptor &amp;tcp_acceptor, AcceptHandler handler)</td></tr>
<tr class="memdesc:a11085b098393116dfd32f893fc8ea95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously accepts a new tcp connection.  <a href="#a11085b098393116dfd32f893fc8ea95d"></a><br/></td></tr>
<tr class="memitem:a177ca42941a50e49396b2ec330e251bf"><td class="memTemplParams" colspan="2">template&lt;typename SSLHandshakeHandler &gt; </td></tr>
<tr class="memitem:a177ca42941a50e49396b2ec330e251bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a177ca42941a50e49396b2ec330e251bf">async_handshake_server</a> (SSLHandshakeHandler handler)</td></tr>
<tr class="memdesc:a177ca42941a50e49396b2ec330e251bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously performs server-side SSL handshake for a new connection.  <a href="#a177ca42941a50e49396b2ec330e251bf"></a><br/></td></tr>
<tr class="memitem:a60d567fd754237b5bfb00004f489435f"><td class="memTemplParams" colspan="2">template&lt;typename ReadHandler &gt; </td></tr>
<tr class="memitem:a60d567fd754237b5bfb00004f489435f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a60d567fd754237b5bfb00004f489435f">async_read_some</a> (ReadHandler handler)</td></tr>
<tr class="memdesc:a60d567fd754237b5bfb00004f489435f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously reads some data into the connection's read buffer.  <a href="#a60d567fd754237b5bfb00004f489435f"></a><br/></td></tr>
<tr class="memitem:a204ad77a69609adc435baecf29c7625e"><td class="memTemplParams" colspan="2">template&lt;typename ReadBufferType , typename ReadHandler &gt; </td></tr>
<tr class="memitem:a204ad77a69609adc435baecf29c7625e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a204ad77a69609adc435baecf29c7625e">async_read_some</a> (ReadBufferType read_buffer, ReadHandler handler)</td></tr>
<tr class="memdesc:a204ad77a69609adc435baecf29c7625e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously reads some data into the connection's read buffer.  <a href="#a204ad77a69609adc435baecf29c7625e"></a><br/></td></tr>
<tr class="memitem:a1ce3c8416bb575d37e057c39084a56b6"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a1ce3c8416bb575d37e057c39084a56b6">read_some</a> (asio::error_code &amp;ec)</td></tr>
<tr class="memdesc:a1ce3c8416bb575d37e057c39084a56b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads some data into the connection's read buffer (blocks until finished)  <a href="#a1ce3c8416bb575d37e057c39084a56b6"></a><br/></td></tr>
<tr class="memitem:a15c1f9b98d8cf70573dc96133a0452f9"><td class="memTemplParams" colspan="2">template&lt;typename ReadBufferType &gt; </td></tr>
<tr class="memitem:a15c1f9b98d8cf70573dc96133a0452f9"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a15c1f9b98d8cf70573dc96133a0452f9">read_some</a> (ReadBufferType read_buffer, asio::error_code &amp;ec)</td></tr>
<tr class="memdesc:a15c1f9b98d8cf70573dc96133a0452f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads some data into the connection's read buffer (blocks until finished)  <a href="#a15c1f9b98d8cf70573dc96133a0452f9"></a><br/></td></tr>
<tr class="memitem:a6eaaee791d1093a59258b3082ef7aa60"><td class="memTemplParams" colspan="2">template&lt;typename CompletionCondition , typename ReadHandler &gt; </td></tr>
<tr class="memitem:a6eaaee791d1093a59258b3082ef7aa60"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a6eaaee791d1093a59258b3082ef7aa60">async_read</a> (CompletionCondition completion_condition, ReadHandler handler)</td></tr>
<tr class="memdesc:a6eaaee791d1093a59258b3082ef7aa60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously reads data into the connection's read buffer until completion_condition is met.  <a href="#a6eaaee791d1093a59258b3082ef7aa60"></a><br/></td></tr>
<tr class="memitem:ad63926d47b0cd29b391bd8c7130719f4"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence , typename CompletionCondition , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ad63926d47b0cd29b391bd8c7130719f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#ad63926d47b0cd29b391bd8c7130719f4">async_read</a> (const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, ReadHandler handler)</td></tr>
<tr class="memdesc:ad63926d47b0cd29b391bd8c7130719f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously reads data from the connection until completion_condition is met.  <a href="#ad63926d47b0cd29b391bd8c7130719f4"></a><br/></td></tr>
<tr class="memitem:a5559ec2dd9e91d2d8e2a68284ae1fe10"><td class="memTemplParams" colspan="2">template&lt;typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a5559ec2dd9e91d2d8e2a68284ae1fe10"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a5559ec2dd9e91d2d8e2a68284ae1fe10">read</a> (CompletionCondition completion_condition, asio::error_code &amp;ec)</td></tr>
<tr class="memdesc:a5559ec2dd9e91d2d8e2a68284ae1fe10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data into the connection's read buffer until completion_condition is met (blocks until finished)  <a href="#a5559ec2dd9e91d2d8e2a68284ae1fe10"></a><br/></td></tr>
<tr class="memitem:aefa100ed1470b65c654a9cfd15b2627f"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:aefa100ed1470b65c654a9cfd15b2627f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#aefa100ed1470b65c654a9cfd15b2627f">read</a> (const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, asio::error_code &amp;ec)</td></tr>
<tr class="memdesc:aefa100ed1470b65c654a9cfd15b2627f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from the connection until completion_condition is met (blocks until finished)  <a href="#aefa100ed1470b65c654a9cfd15b2627f"></a><br/></td></tr>
<tr class="memitem:add2f2ab41a74476529b0e3ab3ca43ee1"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence , typename write_handler_t &gt; </td></tr>
<tr class="memitem:add2f2ab41a74476529b0e3ab3ca43ee1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#add2f2ab41a74476529b0e3ab3ca43ee1">async_write</a> (const ConstBufferSequence &amp;buffers, write_handler_t handler)</td></tr>
<tr class="memdesc:add2f2ab41a74476529b0e3ab3ca43ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously writes data to the connection.  <a href="#add2f2ab41a74476529b0e3ab3ca43ee1"></a><br/></td></tr>
<tr class="memitem:a8c28c3d48160a31bcf80c69ed2199806"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a8c28c3d48160a31bcf80c69ed2199806"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a8c28c3d48160a31bcf80c69ed2199806">write</a> (const ConstBufferSequence &amp;buffers, asio::error_code &amp;ec)</td></tr>
<tr class="memdesc:a8c28c3d48160a31bcf80c69ed2199806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to the connection (blocks until finished)  <a href="#a8c28c3d48160a31bcf80c69ed2199806"></a><br/></td></tr>
<tr class="memitem:a671cffb861a12c805c916926a699217a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a671cffb861a12c805c916926a699217a">finish</a> ()</td></tr>
<tr class="memdesc:a671cffb861a12c805c916926a699217a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function should be called when a server has finished handling the connection.  <a href="#a671cffb861a12c805c916926a699217a"></a><br/></td></tr>
<tr class="memitem:ae4ac6e35b78396f66327ab3063c11588"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#ae4ac6e35b78396f66327ab3063c11588">get_ssl_flag</a> () const </td></tr>
<tr class="memdesc:ae4ac6e35b78396f66327ab3063c11588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the connection is encrypted using SSL.  <a href="#ae4ac6e35b78396f66327ab3063c11588"></a><br/></td></tr>
<tr class="memitem:a440cc929ced689cfe4fe4bec0620162c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a440cc929ced689cfe4fe4bec0620162c">set_lifecycle</a> (<a class="el" href="classpion_1_1tcp_1_1connection.html#a1888aaf31f431a3f00c70c2568f4cb25">lifecycle_type</a> t)</td></tr>
<tr class="memdesc:a440cc929ced689cfe4fe4bec0620162c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the lifecycle type for the connection.  <a href="#a440cc929ced689cfe4fe4bec0620162c"></a><br/></td></tr>
<tr class="memitem:a84895d0d08439207f2d808a23791aa92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpion_1_1tcp_1_1connection.html#a1888aaf31f431a3f00c70c2568f4cb25">lifecycle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a84895d0d08439207f2d808a23791aa92">get_lifecycle</a> () const </td></tr>
<tr class="memdesc:a84895d0d08439207f2d808a23791aa92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lifecycle type for the connection.  <a href="#a84895d0d08439207f2d808a23791aa92"></a><br/></td></tr>
<tr class="memitem:a974b4d93413aaa6a8697b0d87cd4db4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a974b4d93413aaa6a8697b0d87cd4db4f">get_keep_alive</a> () const </td></tr>
<tr class="memdesc:a974b4d93413aaa6a8697b0d87cd4db4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the connection should be kept alive.  <a href="#a974b4d93413aaa6a8697b0d87cd4db4f"></a><br/></td></tr>
<tr class="memitem:a36a1ccefc1c26da113a72a97614b7858"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a36a1ccefc1c26da113a72a97614b7858">get_pipelined</a> () const </td></tr>
<tr class="memdesc:a36a1ccefc1c26da113a72a97614b7858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the HTTP requests are pipelined.  <a href="#a36a1ccefc1c26da113a72a97614b7858"></a><br/></td></tr>
<tr class="memitem:a0cd2d6b1dfbcbd4e625f851cb30cf15d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpion_1_1tcp_1_1connection.html#a099608c1f163f46624069e01a3c1284a">read_buffer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a0cd2d6b1dfbcbd4e625f851cb30cf15d">get_read_buffer</a> ()</td></tr>
<tr class="memdesc:a0cd2d6b1dfbcbd4e625f851cb30cf15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the buffer used for reading data from the TCP connection.  <a href="#a0cd2d6b1dfbcbd4e625f851cb30cf15d"></a><br/></td></tr>
<tr class="memitem:a7951ebfca8e6834faa78417c5e87a748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a7951ebfca8e6834faa78417c5e87a748">save_read_pos</a> (const char *read_ptr, const char *read_end_ptr)</td></tr>
<tr class="memdesc:a7951ebfca8e6834faa78417c5e87a748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a read position bookmark.  <a href="#a7951ebfca8e6834faa78417c5e87a748"></a><br/></td></tr>
<tr class="memitem:a4cc9d7185adda632de1f3482552ed5f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a4cc9d7185adda632de1f3482552ed5f6">load_read_pos</a> (const char *&amp;read_ptr, const char *&amp;read_end_ptr) const </td></tr>
<tr class="memdesc:a4cc9d7185adda632de1f3482552ed5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a read position bookmark.  <a href="#a4cc9d7185adda632de1f3482552ed5f6"></a><br/></td></tr>
<tr class="memitem:a2474ed33ee83a9face42cd597d0a5a09"><td class="memItemLeft" align="right" valign="top">asio::ip::tcp::endpoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a2474ed33ee83a9face42cd597d0a5a09">get_remote_endpoint</a> () const </td></tr>
<tr class="memdesc:a2474ed33ee83a9face42cd597d0a5a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an ASIO endpoint for the client connection.  <a href="#a2474ed33ee83a9face42cd597d0a5a09"></a><br/></td></tr>
<tr class="memitem:a32a764c03bb89e026e6604b79bee7629"><td class="memItemLeft" align="right" valign="top">asio::ip::address&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a32a764c03bb89e026e6604b79bee7629">get_remote_ip</a> () const </td></tr>
<tr class="memdesc:a32a764c03bb89e026e6604b79bee7629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the client's IP address.  <a href="#a32a764c03bb89e026e6604b79bee7629"></a><br/></td></tr>
<tr class="memitem:a8fe2ec4b319a6e690dc26f85e1fd3ef5"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a8fe2ec4b319a6e690dc26f85e1fd3ef5">get_remote_port</a> () const </td></tr>
<tr class="memdesc:a8fe2ec4b319a6e690dc26f85e1fd3ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the client's port number.  <a href="#a8fe2ec4b319a6e690dc26f85e1fd3ef5"></a><br/></td></tr>
<tr class="memitem:a5ef30c8c6cb973b1894b803cda26dd3a"><td class="memItemLeft" align="right" valign="top">asio::io_service &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a5ef30c8c6cb973b1894b803cda26dd3a">get_io_service</a> ()</td></tr>
<tr class="memdesc:a5ef30c8c6cb973b1894b803cda26dd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the io_service used for async operations.  <a href="#a5ef30c8c6cb973b1894b803cda26dd3a"></a><br/></td></tr>
<tr class="memitem:a8621c2baccfa57efd7eb1f08ca1ea10d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpion_1_1tcp_1_1connection.html#a5ca4d0a8aab48603b5d7670960693861">socket_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a8621c2baccfa57efd7eb1f08ca1ea10d">get_socket</a> ()</td></tr>
<tr class="memdesc:a8621c2baccfa57efd7eb1f08ca1ea10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-const reference to underlying TCP socket object.  <a href="#a8621c2baccfa57efd7eb1f08ca1ea10d"></a><br/></td></tr>
<tr class="memitem:a32328563ee76af05c95ebf6fc0dc0f60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpion_1_1tcp_1_1connection_1_1ssl__socket__type.html">ssl_socket_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a32328563ee76af05c95ebf6fc0dc0f60">get_ssl_socket</a> ()</td></tr>
<tr class="memdesc:a32328563ee76af05c95ebf6fc0dc0f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-const reference to underlying SSL socket object.  <a href="#a32328563ee76af05c95ebf6fc0dc0f60"></a><br/></td></tr>
<tr class="memitem:a9ea696909e03a28429b2c8f91a0321e4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpion_1_1tcp_1_1connection.html#a5ca4d0a8aab48603b5d7670960693861">socket_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a9ea696909e03a28429b2c8f91a0321e4">get_socket</a> () const </td></tr>
<tr class="memdesc:a9ea696909e03a28429b2c8f91a0321e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to underlying TCP socket object.  <a href="#a9ea696909e03a28429b2c8f91a0321e4"></a><br/></td></tr>
<tr class="memitem:a4d62c7c540d7d8b586ffcbfd4580facd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpion_1_1tcp_1_1connection_1_1ssl__socket__type.html">ssl_socket_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a4d62c7c540d7d8b586ffcbfd4580facd">get_ssl_socket</a> () const </td></tr>
<tr class="memdesc:a4d62c7c540d7d8b586ffcbfd4580facd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to underlying SSL socket object.  <a href="#a4d62c7c540d7d8b586ffcbfd4580facd"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3e98bb5b8b5a7cefaf050691dd874b52"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classpion_1_1tcp_1_1connection.html">connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a3e98bb5b8b5a7cefaf050691dd874b52">create</a> (asio::io_service &amp;io_service, <a class="el" href="classpion_1_1tcp_1_1connection.html#a8587c35bbf48a119aa82f228e779a30e">ssl_context_type</a> &amp;ssl_context, const bool ssl_flag, <a class="el" href="classpion_1_1tcp_1_1connection.html#afc2e9e9be4eb1d914504aa4d741c9d6c">connection_handler</a> finished_handler)</td></tr>
<tr class="memdesc:a3e98bb5b8b5a7cefaf050691dd874b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates new shared connection objects  <a href="#a3e98bb5b8b5a7cefaf050691dd874b52"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0baef0ac0e5be6912956e3d5469c6539"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1tcp_1_1connection.html#a0baef0ac0e5be6912956e3d5469c6539">connection</a> (asio::io_service &amp;io_service, <a class="el" href="classpion_1_1tcp_1_1connection.html#a8587c35bbf48a119aa82f228e779a30e">ssl_context_type</a> &amp;ssl_context, const bool ssl_flag, <a class="el" href="classpion_1_1tcp_1_1connection.html#afc2e9e9be4eb1d914504aa4d741c9d6c">connection_handler</a> finished_handler)</td></tr>
<tr class="memdesc:a0baef0ac0e5be6912956e3d5469c6539"><td class="mdescLeft">&#160;</td><td class="mdescRight">protected constructor restricts creation of objects (use <a class="el" href="classpion_1_1tcp_1_1connection.html#a3e98bb5b8b5a7cefaf050691dd874b52" title="creates new shared connection objects">create()</a>)  <a href="#a0baef0ac0e5be6912956e3d5469c6539"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Represents a single tcp connection. </p>
</div><h2>Member Typedef Documentation</h2>
<a class="anchor" id="afc2e9e9be4eb1d914504aa4d741c9d6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;void(std::shared_ptr&lt;<a class="el" href="classpion_1_1tcp_1_1connection.html">connection</a>&gt;)&gt; <a class="el" href="classpion_1_1tcp_1_1connection.html#afc2e9e9be4eb1d914504aa4d741c9d6c">pion::tcp::connection::connection_handler</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data type for a function that handles TCP connection objects. </p>

</div>
</div>
<a class="anchor" id="a099608c1f163f46624069e01a3c1284a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::array&lt;char, <a class="el" href="classpion_1_1tcp_1_1connection.html#ad123ec22701e50c2c39d4a6cdbea3e92aac7c4dbea8f7fc8b471d7fcabf619221">READ_BUFFER_SIZE</a>&gt; <a class="el" href="classpion_1_1tcp_1_1connection.html#a099608c1f163f46624069e01a3c1284a">pion::tcp::connection::read_buffer_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data type for an I/O read buffer. </p>

</div>
</div>
<a class="anchor" id="a5ca4d0a8aab48603b5d7670960693861"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef asio::ip::tcp::socket <a class="el" href="classpion_1_1tcp_1_1connection.html#a5ca4d0a8aab48603b5d7670960693861">pion::tcp::connection::socket_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data type for a socket connection. </p>

</div>
</div>
<a class="anchor" id="a8587c35bbf48a119aa82f228e779a30e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="classpion_1_1tcp_1_1connection.html#a8587c35bbf48a119aa82f228e779a30e">pion::tcp::connection::ssl_context_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dummy data type for SSL configuration context in non-SSL environment. </p>

</div>
</div>
<h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ad123ec22701e50c2c39d4a6cdbea3e92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the read buffer. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad123ec22701e50c2c39d4a6cdbea3e92aac7c4dbea8f7fc8b471d7fcabf619221"></a>READ_BUFFER_SIZE</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a1888aaf31f431a3f00c70c2568f4cb25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpion_1_1tcp_1_1connection.html#a1888aaf31f431a3f00c70c2568f4cb25">pion::tcp::connection::lifecycle_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data type for the connection's lifecycle state. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a1888aaf31f431a3f00c70c2568f4cb25a1eee3589ec1f6b59a13bc36fd5f48e63"></a>LIFECYCLE_CLOSE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1888aaf31f431a3f00c70c2568f4cb25ab3bb67380ff48e263e16b55ff786e96f"></a>LIFECYCLE_KEEPALIVE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1888aaf31f431a3f00c70c2568f4cb25ac3e9ae9a9b7a71232679416d57b7d95f"></a>LIFECYCLE_PIPELINED</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acfec04a4c239aabdfd7842471101e325"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pion::tcp::connection::connection </td>
          <td>(</td>
          <td class="paramtype">asio::io_service &amp;&#160;</td>
          <td class="paramname"><em>io_service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpion_1_1tcp_1_1connection.html#a8587c35bbf48a119aa82f228e779a30e">ssl_context_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ssl_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a new connection object for SSL </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_service</td><td>asio service associated with the connection </td></tr>
    <tr><td class="paramname">ssl_context</td><td>asio ssl context associated with the connection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4fbf93efbbb9f67dbe882c33ce3964da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual pion::tcp::connection::~connection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual destructor. </p>

</div>
</div>
<a class="anchor" id="a0baef0ac0e5be6912956e3d5469c6539"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pion::tcp::connection::connection </td>
          <td>(</td>
          <td class="paramtype">asio::io_service &amp;&#160;</td>
          <td class="paramname"><em>io_service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpion_1_1tcp_1_1connection.html#a8587c35bbf48a119aa82f228e779a30e">ssl_context_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ssl_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ssl_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpion_1_1tcp_1_1connection.html#afc2e9e9be4eb1d914504aa4d741c9d6c">connection_handler</a>&#160;</td>
          <td class="paramname"><em>finished_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>protected constructor restricts creation of objects (use <a class="el" href="classpion_1_1tcp_1_1connection.html#a3e98bb5b8b5a7cefaf050691dd874b52" title="creates new shared connection objects">create()</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_service</td><td>asio service associated with the connection </td></tr>
    <tr><td class="paramname">ssl_context</td><td>asio ssl context associated with the connection </td></tr>
    <tr><td class="paramname">ssl_flag</td><td>if true then the connection will be encrypted using SSL </td></tr>
    <tr><td class="paramname">finished_handler</td><td>function called when a server has finished handling the connection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a11085b098393116dfd32f893fc8ea95d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AcceptHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pion::tcp::connection::async_accept </td>
          <td>(</td>
          <td class="paramtype">asio::ip::tcp::acceptor &amp;&#160;</td>
          <td class="paramname"><em>tcp_acceptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AcceptHandler&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously accepts a new tcp connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tcp_acceptor</td><td>object used to accept new connections </td></tr>
    <tr><td class="paramname">handler</td><td>called after a new connection has been accepted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>asio::basic_socket_acceptor::async_accept() </dd></dl>

</div>
</div>
<a class="anchor" id="a177ca42941a50e49396b2ec330e251bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SSLHandshakeHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pion::tcp::connection::async_handshake_server </td>
          <td>(</td>
          <td class="paramtype">SSLHandshakeHandler&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously performs server-side SSL handshake for a new connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>called after the ssl handshake has completed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>asio::ssl::stream::async_handshake() </dd></dl>

</div>
</div>
<a class="anchor" id="a6eaaee791d1093a59258b3082ef7aa60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionCondition , typename ReadHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pion::tcp::connection::async_read </td>
          <td>(</td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously reads data into the connection's read buffer until completion_condition is met. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">completion_condition</td><td>determines if the read operation is complete </td></tr>
    <tr><td class="paramname">handler</td><td>called after the read operation has completed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>asio::async_read() </dd></dl>

</div>
</div>
<a class="anchor" id="ad63926d47b0cd29b391bd8c7130719f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBufferSequence , typename CompletionCondition , typename ReadHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pion::tcp::connection::async_read </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously reads data from the connection until completion_condition is met. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>one or more buffers into which the data will be read </td></tr>
    <tr><td class="paramname">completion_condition</td><td>determines if the read operation is complete </td></tr>
    <tr><td class="paramname">handler</td><td>called after the read operation has completed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>asio::async_read() </dd></dl>

</div>
</div>
<a class="anchor" id="a60d567fd754237b5bfb00004f489435f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReadHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pion::tcp::connection::async_read_some </td>
          <td>(</td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously reads some data into the connection's read buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>called after the read operation has completed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>asio::basic_stream_socket::async_read_some() </dd></dl>

</div>
</div>
<a class="anchor" id="a204ad77a69609adc435baecf29c7625e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReadBufferType , typename ReadHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pion::tcp::connection::async_read_some </td>
          <td>(</td>
          <td class="paramtype">ReadBufferType&#160;</td>
          <td class="paramname"><em>read_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously reads some data into the connection's read buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_buffer</td><td>the buffer to read data into </td></tr>
    <tr><td class="paramname">handler</td><td>called after the read operation has completed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>asio::basic_stream_socket::async_read_some() </dd></dl>

</div>
</div>
<a class="anchor" id="add2f2ab41a74476529b0e3ab3ca43ee1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConstBufferSequence , typename write_handler_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pion::tcp::connection::async_write </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">write_handler_t&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously writes data to the connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>one or more buffers containing the data to be written </td></tr>
    <tr><td class="paramname">handler</td><td>called after the data has been written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>asio::async_write() </dd></dl>

</div>
</div>
<a class="anchor" id="a40e5a1fb2afd5c9d2696f15e4090bbe5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pion::tcp::connection::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancels any asynchronous operations pending on the socket. </p>

</div>
</div>
<a class="anchor" id="ac544e2fda25b3fb88407edb471a2f869"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pion::tcp::connection::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the tcp socket and cancels any pending asynchronous operations. </p>

</div>
</div>
<a class="anchor" id="a3e98bb5b8b5a7cefaf050691dd874b52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classpion_1_1tcp_1_1connection.html">connection</a>&gt; pion::tcp::connection::create </td>
          <td>(</td>
          <td class="paramtype">asio::io_service &amp;&#160;</td>
          <td class="paramname"><em>io_service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpion_1_1tcp_1_1connection.html#a8587c35bbf48a119aa82f228e779a30e">ssl_context_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ssl_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ssl_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpion_1_1tcp_1_1connection.html#afc2e9e9be4eb1d914504aa4d741c9d6c">connection_handler</a>&#160;</td>
          <td class="paramname"><em>finished_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates new shared connection objects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_service</td><td>asio service associated with the connection </td></tr>
    <tr><td class="paramname">ssl_context</td><td>asio ssl context associated with the connection </td></tr>
    <tr><td class="paramname">ssl_flag</td><td>if true then the connection will be encrypted using SSL </td></tr>
    <tr><td class="paramname">finished_handler</td><td>function called when a server has finished handling the connection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a671cffb861a12c805c916926a699217a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pion::tcp::connection::finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function should be called when a server has finished handling the connection. </p>

</div>
</div>
<a class="anchor" id="a5ef30c8c6cb973b1894b803cda26dd3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asio::io_service&amp; pion::tcp::connection::get_io_service </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to the io_service used for async operations. </p>
<dl class="section return"><dt>Returns</dt><dd>io_service used for async operations </dd></dl>

</div>
</div>
<a class="anchor" id="a974b4d93413aaa6a8697b0d87cd4db4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pion::tcp::connection::get_keep_alive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the connection should be kept alive. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a84895d0d08439207f2d808a23791aa92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpion_1_1tcp_1_1connection.html#a1888aaf31f431a3f00c70c2568f4cb25">lifecycle_type</a> pion::tcp::connection::get_lifecycle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the lifecycle type for the connection. </p>
<dl class="section return"><dt>Returns</dt><dd>lifecycle type name </dd></dl>

</div>
</div>
<a class="anchor" id="a36a1ccefc1c26da113a72a97614b7858"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pion::tcp::connection::get_pipelined </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the HTTP requests are pipelined. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the HTTP requests are pipelined </dd></dl>

</div>
</div>
<a class="anchor" id="a0cd2d6b1dfbcbd4e625f851cb30cf15d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpion_1_1tcp_1_1connection.html#a099608c1f163f46624069e01a3c1284a">read_buffer_type</a>&amp; pion::tcp::connection::get_read_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the buffer used for reading data from the TCP connection. </p>
<dl class="section return"><dt>Returns</dt><dd>buffer used for reading data from the TCP connection </dd></dl>

</div>
</div>
<a class="anchor" id="a2474ed33ee83a9face42cd597d0a5a09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asio::ip::tcp::endpoint pion::tcp::connection::get_remote_endpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an ASIO endpoint for the client connection. </p>
<dl class="section return"><dt>Returns</dt><dd>endpoint </dd></dl>

</div>
</div>
<a class="anchor" id="a32a764c03bb89e026e6604b79bee7629"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asio::ip::address pion::tcp::connection::get_remote_ip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the client's IP address. </p>
<dl class="section return"><dt>Returns</dt><dd>client's IP address </dd></dl>

</div>
</div>
<a class="anchor" id="a8fe2ec4b319a6e690dc26f85e1fd3ef5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short pion::tcp::connection::get_remote_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the client's port number. </p>
<dl class="section return"><dt>Returns</dt><dd>client's port number </dd></dl>

</div>
</div>
<a class="anchor" id="a8621c2baccfa57efd7eb1f08ca1ea10d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpion_1_1tcp_1_1connection.html#a5ca4d0a8aab48603b5d7670960693861">socket_type</a>&amp; pion::tcp::connection::get_socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns non-const reference to underlying TCP socket object. </p>
<dl class="section return"><dt>Returns</dt><dd>underlying TCP socket object </dd></dl>

</div>
</div>
<a class="anchor" id="a9ea696909e03a28429b2c8f91a0321e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpion_1_1tcp_1_1connection.html#a5ca4d0a8aab48603b5d7670960693861">socket_type</a>&amp; pion::tcp::connection::get_socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns const reference to underlying TCP socket object. </p>
<dl class="section return"><dt>Returns</dt><dd>underlying TCP socket object </dd></dl>

</div>
</div>
<a class="anchor" id="ae4ac6e35b78396f66327ab3063c11588"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pion::tcp::connection::get_ssl_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the connection is encrypted using SSL. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the connection is encrypted using SSL </dd></dl>

</div>
</div>
<a class="anchor" id="a32328563ee76af05c95ebf6fc0dc0f60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpion_1_1tcp_1_1connection_1_1ssl__socket__type.html">ssl_socket_type</a>&amp; pion::tcp::connection::get_ssl_socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns non-const reference to underlying SSL socket object. </p>
<dl class="section return"><dt>Returns</dt><dd>underlying SSL socket object </dd></dl>

</div>
</div>
<a class="anchor" id="a4d62c7c540d7d8b586ffcbfd4580facd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpion_1_1tcp_1_1connection_1_1ssl__socket__type.html">ssl_socket_type</a>&amp; pion::tcp::connection::get_ssl_socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns const reference to underlying SSL socket object. </p>
<dl class="section return"><dt>Returns</dt><dd>underlying SSL socket object </dd></dl>

</div>
</div>
<a class="anchor" id="a8fe2d278e93663648d844004a4b8ddc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pion::tcp::connection::is_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the connection is currently open. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the connection is currently open </dd></dl>

</div>
</div>
<a class="anchor" id="a4cc9d7185adda632de1f3482552ed5f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pion::tcp::connection::load_read_pos </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>read_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>read_end_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a read position bookmark. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_ptr</td><td>points to the next character to be consumed in the read_buffer </td></tr>
    <tr><td class="paramname">read_end_ptr</td><td>points to the end of the read_buffer (last byte + 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5559ec2dd9e91d2d8e2a68284ae1fe10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t pion::tcp::connection::read </td>
          <td>(</td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asio::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data into the connection's read buffer until completion_condition is met (blocks until finished) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">completion_condition</td><td>determines if the read operation is complete </td></tr>
    <tr><td class="paramname">ec</td><td>contains error code if the read fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::size_t number of bytes read</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>asio::read() </dd></dl>

</div>
</div>
<a class="anchor" id="aefa100ed1470b65c654a9cfd15b2627f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBufferSequence , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t pion::tcp::connection::read </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asio::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data from the connection until completion_condition is met (blocks until finished) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>one or more buffers into which the data will be read </td></tr>
    <tr><td class="paramname">completion_condition</td><td>determines if the read operation is complete </td></tr>
    <tr><td class="paramname">ec</td><td>contains error code if the read fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::size_t number of bytes read</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>asio::read() </dd></dl>

</div>
</div>
<a class="anchor" id="a1ce3c8416bb575d37e057c39084a56b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t pion::tcp::connection::read_some </td>
          <td>(</td>
          <td class="paramtype">asio::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads some data into the connection's read buffer (blocks until finished) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>contains error code if the read fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::size_t number of bytes read</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>asio::basic_stream_socket::read_some() </dd></dl>

</div>
</div>
<a class="anchor" id="a15c1f9b98d8cf70573dc96133a0452f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReadBufferType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t pion::tcp::connection::read_some </td>
          <td>(</td>
          <td class="paramtype">ReadBufferType&#160;</td>
          <td class="paramname"><em>read_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asio::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reads some data into the connection's read buffer (blocks until finished) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_buffer</td><td>the buffer to read data into </td></tr>
    <tr><td class="paramname">ec</td><td>contains error code if the read fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::size_t number of bytes read</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>asio::basic_stream_socket::read_some() </dd></dl>

</div>
</div>
<a class="anchor" id="a7951ebfca8e6834faa78417c5e87a748"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pion::tcp::connection::save_read_pos </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>read_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>read_end_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a read position bookmark. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_ptr</td><td>points to the next character to be consumed in the read_buffer </td></tr>
    <tr><td class="paramname">read_end_ptr</td><td>points to the end of the read_buffer (last byte + 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a440cc929ced689cfe4fe4bec0620162c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pion::tcp::connection::set_lifecycle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpion_1_1tcp_1_1connection.html#a1888aaf31f431a3f00c70c2568f4cb25">lifecycle_type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the lifecycle type for the connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>lifecycle type name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c28c3d48160a31bcf80c69ed2199806"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t pion::tcp::connection::write </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asio::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data to the connection (blocks until finished) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>one or more buffers containing the data to be written </td></tr>
    <tr><td class="paramname">ec</td><td>contains error code if the write fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::size_t number of bytes written</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>asio::write() </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pion/tcp/<a class="el" href="connection_8hpp_source.html">connection.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Sep 5 2015 19:57:25 for staticlib_httpserver by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
